<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tessella</title>
<style>
  /* Local fonts */
  @font-face {
    font-family: 'Space Mono';
    src: url('/fonts/SpaceMono-Regular.woff2') format('woff2');
    font-weight: 400;
    font-style: normal;
  }
  @font-face {
    font-family: 'Space Mono';
    src: url('/fonts/SpaceMono-Bold.woff2') format('woff2');
    font-weight: 700;
    font-style: normal;
  }
  @font-face {
    font-family: 'Playfair Display';
    src: url('/fonts/PlayfairDisplay-Regular.woff2') format('woff2');
    font-weight: 400;
    font-style: normal;
  }
  @font-face {
    font-family: 'Playfair Display';
    src: url('/fonts/PlayfairDisplay-Bold.woff2') format('woff2');
    font-weight: 700;
    font-style: normal;
  }
  @font-face {
    font-family: 'Playfair Display';
    src: url('/fonts/PlayfairDisplay-Black.woff2') format('woff2');
    font-weight: 900;
    font-style: normal;
  }
  @font-face {
    font-family: 'JetBrains Mono';
    src: url('/fonts/JetBrainsMono-Regular.woff2') format('woff2');
    font-weight: 400;
    font-style: normal;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    background: #0a0a0a;
    color: #ffffff;
    font-family: 'Space Mono', monospace;
    cursor: none;
    user-select: none;
  }

  #canvas {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  /* --- Idle state: subtle breathing animation --- */
  #idle-indicator {
    position: absolute;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 0.7rem;
    color: rgba(255,255,255,0.15);
    letter-spacing: 0.3em;
    text-transform: uppercase;
    animation: breathe 4s ease-in-out infinite;
  }

  #client-id {
    position: absolute;
    top: 15px;
    right: 20px;
    font-size: 0.6rem;
    color: rgba(255,255,255,0.08);
    font-family: 'JetBrains Mono', monospace;
  }

  @keyframes breathe {
    0%, 100% { opacity: 0.15; }
    50% { opacity: 0.4; }
  }

  /* --- Content layers --- */
  .content-layer {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 40px;
    z-index: 10;
  }

  .content-layer.pos-top { align-items: flex-start; padding-top: 80px; }
  .content-layer.pos-bottom { align-items: flex-end; padding-bottom: 80px; }
  .content-layer.pos-left { justify-content: flex-start; padding-left: 80px; }
  .content-layer.pos-right { justify-content: flex-end; padding-right: 80px; }

  /* --- Text styles --- */
  .display-text {
    font-family: 'Playfair Display', serif;
    text-align: center;
    line-height: 1.3;
    max-width: 90%;
    word-wrap: break-word;
  }

  /* --- Image styles --- */
  .display-image {
    max-width: 90%;
    max-height: 90vh;
    object-fit: contain;
    border-radius: 2px;
  }

  .display-image.fit-cover {
    width: 100%;
    height: 100%;
    object-fit: cover;
    max-width: 100%;
    max-height: 100%;
    border-radius: 0;
  }

  /* Tiled image - shows a portion of a larger image */
  .display-tile {
    position: absolute;
    inset: 0;
    background-repeat: no-repeat;
  }

  /* --- Video styles --- */
  .display-video {
    max-width: 100%;
    max-height: 100vh;
    object-fit: contain;
  }

  .display-video.fit-cover {
    width: 100%;
    height: 100%;
    object-fit: cover;
    max-width: 100%;
    max-height: 100%;
  }

  /* --- Animations --- */

  /* Fade */
  .anim-fade-in {
    animation: fadeIn 1.5s ease-out forwards;
  }
  .anim-fade-out {
    animation: fadeOut 1s ease-in forwards;
  }
  @keyframes fadeIn {
    from { opacity: 0; transform: scale(0.95); }
    to { opacity: 1; transform: scale(1); }
  }
  @keyframes fadeOut {
    from { opacity: 1; }
    to { opacity: 0; }
  }

  /* Slide up */
  .anim-slide-up {
    animation: slideUp 1s cubic-bezier(0.16, 1, 0.3, 1) forwards;
  }
  @keyframes slideUp {
    from { opacity: 0; transform: translateY(60px); }
    to { opacity: 1; transform: translateY(0); }
  }

  /* Typewriter */
  .typewriter-cursor::after {
    content: '▌';
    animation: blink 0.8s step-end infinite;
    color: rgba(255,255,255,0.6);
  }
  @keyframes blink {
    50% { opacity: 0; }
  }

  /* Glitch effect */
  .effect-glitch {
    animation: glitch 0.3s linear infinite;
  }
  @keyframes glitch {
    0% { transform: translate(0); filter: hue-rotate(0deg); }
    20% { transform: translate(-3px, 3px); filter: hue-rotate(90deg); }
    40% { transform: translate(3px, -3px); filter: hue-rotate(180deg); }
    60% { transform: translate(-2px, -2px); filter: hue-rotate(270deg); }
    80% { transform: translate(2px, 2px); filter: hue-rotate(360deg); }
    100% { transform: translate(0); }
  }

  /* Pulse effect */
  .effect-pulse {
    animation: pulse 0.6s ease-in-out 3;
  }
  @keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.08); }
  }

  /* Wave effect */
  .effect-wave .display-text {
    animation: wave 2s ease-in-out;
  }
  @keyframes wave {
    0% { transform: translateY(0) rotate(0deg); }
    25% { transform: translateY(-20px) rotate(-2deg); }
    50% { transform: translateY(0) rotate(0deg); }
    75% { transform: translateY(-10px) rotate(1deg); }
    100% { transform: translateY(0) rotate(0deg); }
  }

  /* Flash effect */
  .effect-flash {
    animation: flash 0.15s linear 3;
  }
  @keyframes flash {
    0%, 100% { background: #0a0a0a; }
    50% { background: #ffffff; }
  }

  /* Noise overlay */
  #noise {
    position: fixed;
    inset: 0;
    z-index: 999;
    pointer-events: none;
    opacity: 0.03;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
    background-size: 200px 200px;
  }

  /* Fullscreen prompt */
  #fs-prompt {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    cursor: pointer;
  }
  #fs-prompt span {
    font-size: 1.2rem;
    color: rgba(255,255,255,0.5);
    letter-spacing: 0.2em;
    text-transform: uppercase;
    animation: breathe 2s ease-in-out infinite;
  }
  #fs-prompt.hidden { display: none; }

  /* Connection status */
  #status-dot {
    position: absolute;
    top: 15px;
    left: 20px;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #333;
    transition: background 0.5s;
  }
  #status-dot.connected { background: #2ecc40; }
  #status-dot.disconnected { background: #ff4136; }

  /* Eyeball container */
  #eyeball-container {
    position: absolute;
    inset: 0;
    z-index: 5;
    display: none;
  }
  #eyeball-container.active {
    display: block;
  }
</style>
</head>
<body>

<div id="fs-prompt" onclick="goFullscreen()">
  <span>Klick für Vollbild</span>
</div>

<div id="noise"></div>
<div id="status-dot"></div>
<div id="client-id"></div>
<div id="canvas">
  <div id="idle-indicator">bereit</div>
</div>
<div id="eyeball-container"></div>

<script src="/lib/three.min.js"></script>
<script>
// --- Fullscreen ---
function goFullscreen() {
  const el = document.documentElement;
  const rfs = el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen;
  if (rfs) {
    rfs.call(el).catch(() => {});
  }
  // Always dismiss the prompt (iOS doesn't support fullscreen API)
  document.getElementById('fs-prompt').classList.add('hidden');
}

// --- WebSocket ---
let ws;
let clientInfo = { id: 0, name: 'Laptop' };
let reconnectTimer;

function connect() {
  const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
  ws = new WebSocket(`${protocol}//${location.host}?role=client`);

  ws.onopen = () => {
    console.log('Connected');
    document.getElementById('status-dot').className = 'connected';
    if (reconnectTimer) clearInterval(reconnectTimer);
  };

  ws.onclose = () => {
    document.getElementById('status-dot').className = 'disconnected';
    reconnectTimer = setTimeout(connect, 2000);
  };

  ws.onerror = () => ws.close();

  ws.onmessage = (event) => {
    try {
      const msg = JSON.parse(event.data);
      handleMessage(msg);
    } catch (e) {
      console.error('Parse error:', e);
    }
  };
}

function handleMessage(msg) {
  switch (msg.type) {
    case 'identity':
      clientInfo = msg;
      document.getElementById('client-id').textContent = `#${msg.id} ${msg.name}`;
      document.title = `Display #${msg.id}`;
      break;

    case 'content-history':
      msg.items.forEach((item, i) => {
        setTimeout(() => handleMessage(item), i * 200);
      });
      break;

    case 'show-text':
      showText(msg);
      break;

    case 'show-image':
      showImage(msg);
      break;

    case 'show-tiled-image':
      showTiledImage(msg);
      break;

    case 'show-video':
      showVideo(msg);
      break;

    case 'video-control':
      controlVideo(msg);
      break;

    case 'show-color':
      document.body.style.background = msg.color;
      break;

    case 'clear':
      clearContent(msg.style);
      break;

    case 'effect':
      applyEffect(msg.effect, msg.duration);
      break;

    case 'show-eyeball':
      showEyeball(msg);
      break;

    case 'eyeball-gaze':
      updateEyeballGaze(msg);
      break;

    case 'hide-eyeball':
      hideEyeball();
      break;

    case 'config-display':
      configureDisplay(msg);
      break;
  }
}

function showText(msg) {
  hideIdle();
  const layer = createLayer(msg.position);
  const el = document.createElement('div');
  el.className = 'display-text';
  el.style.fontSize = msg.fontSize || '2rem';
  el.style.color = msg.color || '#ffffff';

  if (msg.style === 'typewriter') {
    el.classList.add('typewriter-cursor');
    layer.appendChild(el);
    typewriterEffect(el, msg.text, () => {
      el.classList.remove('typewriter-cursor');
    });
  } else if (msg.style === 'slide') {
    el.textContent = msg.text;
    el.classList.add('anim-slide-up');
    layer.appendChild(el);
  } else {
    el.textContent = msg.text;
    el.classList.add('anim-fade-in');
    layer.appendChild(el);
  }

  document.getElementById('canvas').appendChild(layer);
}

function showImage(msg) {
  hideIdle();
  const layer = createLayer(msg.position);
  const img = document.createElement('img');
  img.className = 'display-image anim-fade-in';
  if (msg.fit === 'cover') img.classList.add('fit-cover');
  img.src = msg.url;
  img.onerror = () => {
    // Show error as text
    const errEl = document.createElement('div');
    errEl.className = 'display-text anim-fade-in';
    errEl.style.fontSize = '1rem';
    errEl.style.color = 'rgba(255,100,100,0.5)';
    errEl.textContent = '⚠ Bild nicht ladbar';
    layer.appendChild(errEl);
  };
  layer.appendChild(img);
  document.getElementById('canvas').appendChild(layer);
}

function showTiledImage(msg) {
  hideIdle();
  const { tile, url, style, preserveAspect } = msg;
  const { col, row, cols, rows } = tile;

  if (preserveAspect) {
    // Load image to get dimensions for aspect-ratio-aware tiling
    const img = new Image();
    img.onload = () => {
      const imgRatio = img.naturalWidth / img.naturalHeight;
      const vpRatio = window.innerWidth / window.innerHeight;

      // Calculate scaled size to "cover" the combined display area
      // while maintaining aspect ratio
      let scaledW, scaledH;

      // Try scaling by width first
      scaledW = cols;
      scaledH = cols / imgRatio * vpRatio;

      if (scaledH < rows) {
        // Width scaling doesn't cover height, scale by height instead
        scaledH = rows;
        scaledW = rows * imgRatio / vpRatio;
      }

      // Background size as percentage of viewport
      const bgWidthPct = scaledW * 100;
      const bgHeightPct = scaledH * 100;

      // Center offset (excess on each side)
      const xExcess = scaledW - cols;
      const yExcess = scaledH - rows;

      // This tile's position in the scaled image
      const tileX = xExcess / 2 + col;
      const tileY = yExcess / 2 + row;

      // Convert to background-position percentage
      const xPos = scaledW > 1 ? (tileX / (scaledW - 1)) * 100 : 50;
      const yPos = scaledH > 1 ? (tileY / (scaledH - 1)) * 100 : 50;

      createTileElement(url, bgWidthPct, bgHeightPct, xPos, yPos);
    };
    img.onerror = () => {
      // Fallback to stretch mode on error
      createTileElement(url, cols * 100, rows * 100,
        cols > 1 ? (col / (cols - 1)) * 100 : 0,
        rows > 1 ? (row / (rows - 1)) * 100 : 0
      );
    };
    img.src = url;
  } else {
    // Original stretch behavior
    const bgWidthPct = cols * 100;
    const bgHeightPct = rows * 100;
    const xPos = cols > 1 ? (col / (cols - 1)) * 100 : 0;
    const yPos = rows > 1 ? (row / (rows - 1)) * 100 : 0;
    createTileElement(url, bgWidthPct, bgHeightPct, xPos, yPos);
  }
}

function createTileElement(url, bgWidth, bgHeight, xPos, yPos) {
  const layer = document.createElement('div');
  layer.className = 'content-layer';

  const tileEl = document.createElement('div');
  tileEl.className = 'display-tile anim-fade-in';

  tileEl.style.backgroundSize = `${bgWidth}% ${bgHeight}%`;
  tileEl.style.backgroundPosition = `${xPos}% ${yPos}%`;
  tileEl.style.backgroundImage = `url('${url}')`;

  layer.appendChild(tileEl);
  document.getElementById('canvas').appendChild(layer);
}

let currentVideo = null;

function showVideo(msg) {
  hideIdle();
  // Remove any existing video first
  if (currentVideo) {
    currentVideo.pause();
    currentVideo.parentElement?.remove();
    currentVideo = null;
  }

  const layer = createLayer(msg.position);
  const video = document.createElement('video');
  video.className = 'display-video anim-fade-in';
  video.id = 'active-video';

  if (msg.fit === 'cover') video.classList.add('fit-cover');

  video.src = msg.url;
  video.loop = msg.loop !== false;
  video.muted = msg.muted !== false; // Muted by default for autoplay
  video.playsInline = true;
  video.preload = 'auto';

  video.onerror = () => {
    const errEl = document.createElement('div');
    errEl.className = 'display-text anim-fade-in';
    errEl.style.fontSize = '1rem';
    errEl.style.color = 'rgba(255,100,100,0.5)';
    errEl.textContent = '⚠ Video nicht ladbar';
    layer.appendChild(errEl);
  };

  video.oncanplay = () => {
    if (msg.autoplay !== false) {
      video.play().catch(e => {
        console.log('Autoplay blocked:', e);
        // Try muted autoplay as fallback
        video.muted = true;
        video.play().catch(() => {});
      });
    }
  };

  layer.appendChild(video);
  document.getElementById('canvas').appendChild(layer);
  currentVideo = video;
}

function controlVideo(msg) {
  const video = currentVideo || document.getElementById('active-video');
  if (!video) return;

  switch (msg.action) {
    case 'play':
      video.play().catch(() => {});
      break;
    case 'pause':
      video.pause();
      break;
    case 'stop':
      video.pause();
      video.currentTime = 0;
      break;
    case 'mute':
      video.muted = true;
      break;
    case 'unmute':
      video.muted = false;
      break;
    case 'seek':
      if (typeof msg.time === 'number') {
        video.currentTime = msg.time;
      }
      break;
    case 'sync':
      // Sync to a target time (for coordinated playback)
      if (typeof msg.time === 'number') {
        const diff = Math.abs(video.currentTime - msg.time);
        if (diff > 0.5) { // Only sync if drift is significant
          video.currentTime = msg.time;
        }
      }
      if (msg.playing && video.paused) {
        video.play().catch(() => {});
      } else if (!msg.playing && !video.paused) {
        video.pause();
      }
      break;
  }
}

function clearContent(style) {
  // Stop and clear any playing video
  if (currentVideo) {
    currentVideo.pause();
    currentVideo = null;
  }

  // Hide eyeball if active
  if (eyeballActive) {
    hideEyeball();
  }

  const layers = document.querySelectorAll('.content-layer');
  layers.forEach(layer => {
    layer.classList.add('anim-fade-out');
    setTimeout(() => layer.remove(), 1000);
  });
  setTimeout(() => {
    document.body.style.background = '#0a0a0a';
    showIdle();
  }, 1100);
}

function applyEffect(effect, duration) {
  const canvas = document.getElementById('canvas');
  canvas.classList.add(`effect-${effect}`);
  if (effect === 'flash') {
    document.body.classList.add('effect-flash');
    setTimeout(() => document.body.classList.remove('effect-flash'), duration);
  }
  setTimeout(() => canvas.classList.remove(`effect-${effect}`), duration);
}

// --- Helpers ---

function createLayer(position) {
  const layer = document.createElement('div');
  layer.className = 'content-layer';
  if (position && position !== 'center') {
    layer.classList.add(`pos-${position}`);
  }
  return layer;
}

function typewriterEffect(el, text, onComplete) {
  let i = 0;
  const speed = 50 + Math.random() * 30;
  function type() {
    if (i < text.length) {
      el.textContent += text.charAt(i);
      i++;
      setTimeout(type, speed + (Math.random() * 20 - 10));
    } else {
      if (onComplete) onComplete();
    }
  }
  type();
}

function hideIdle() {
  const idle = document.getElementById('idle-indicator');
  if (idle) idle.style.display = 'none';
}

function showIdle() {
  const idle = document.getElementById('idle-indicator');
  if (idle) idle.style.display = 'block';
}

// --- Eyeball System ---
let eyeballScene = null;
let eyeballCamera = null;
let eyeballRenderer = null;
let eyeballGroup = null;
let eyeballPupil = null;
let eyeballActive = false;
let targetGaze = { x: 0, y: 0 };
let currentGaze = { x: 0, y: 0 };
let displayConfig = {
  position: { x: 0, y: 0, z: 0 },
  rotation: 0 // facing direction in degrees (0 = toward audience)
};

// Named mesh references
let eyeballIris = null;
let eyeballSclera = null;
let eyeballCornea = null;
let eyeballUpperLid = null;
let eyeballLowerLid = null;

// Iris texture state
let irisCanvas = null;
let irisTexture = null;
let currentIrisColor = '#4a7c59';

// Pupil dilation state
let pupilDilationTarget = 1.0;
let pupilDilationCurrent = 1.0;
let nextDilationChangeTime = 0;

// Blink state
let blinkState = 'open'; // open, closing, closed, opening
let blinkProgress = 0;
let nextBlinkTime = 0;
let blinkSpeed = 8; // speed multiplier for blink animation

function parseColorToRGB(colorStr) {
  const c = document.createElement('canvas');
  c.width = c.height = 1;
  const ctx = c.getContext('2d');
  ctx.fillStyle = colorStr;
  ctx.fillRect(0, 0, 1, 1);
  const d = ctx.getImageData(0, 0, 1, 1).data;
  return { r: d[0], g: d[1], b: d[2] };
}

function easeInOutCubic(t) {
  return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

function generateIrisTexture(colorString) {
  const size = 512;
  const canvas = document.createElement('canvas');
  canvas.width = canvas.height = size;
  const ctx = canvas.getContext('2d');
  const cx = size / 2, cy = size / 2;
  const irisRadius = size * 0.48;
  const pupilRadius = size * 0.18;

  // Background transparent
  ctx.clearRect(0, 0, size, size);

  const rgb = parseColorToRGB(colorString);

  // Base iris fill
  const baseGrad = ctx.createRadialGradient(cx, cy, pupilRadius, cx, cy, irisRadius);
  baseGrad.addColorStop(0, `rgb(${Math.floor(rgb.r * 0.6)},${Math.floor(rgb.g * 0.6)},${Math.floor(rgb.b * 0.6)})`);
  baseGrad.addColorStop(0.5, colorString);
  baseGrad.addColorStop(0.85, `rgb(${Math.floor(rgb.r * 0.7)},${Math.floor(rgb.g * 0.7)},${Math.floor(rgb.b * 0.7)})`);
  baseGrad.addColorStop(1, `rgb(${Math.floor(rgb.r * 0.3)},${Math.floor(rgb.g * 0.3)},${Math.floor(rgb.b * 0.3)})`);
  ctx.beginPath();
  ctx.arc(cx, cy, irisRadius, 0, Math.PI * 2);
  ctx.fillStyle = baseGrad;
  ctx.fill();

  // Radial fibers
  ctx.save();
  ctx.globalCompositeOperation = 'overlay';
  for (let i = 0; i < 120; i++) {
    const angle = (i / 120) * Math.PI * 2 + (Math.random() - 0.5) * 0.05;
    const innerR = pupilRadius + Math.random() * 10;
    const outerR = irisRadius * (0.6 + Math.random() * 0.38);
    const hueShift = (Math.random() - 0.5) * 30;
    const lightness = 40 + Math.random() * 30;
    ctx.beginPath();
    ctx.moveTo(cx + Math.cos(angle) * innerR, cy + Math.sin(angle) * innerR);
    ctx.lineTo(cx + Math.cos(angle) * outerR, cy + Math.sin(angle) * outerR);
    ctx.strokeStyle = `hsla(${hueShift}, 30%, ${lightness}%, 0.15)`;
    ctx.lineWidth = 1 + Math.random() * 2;
    ctx.stroke();
  }
  ctx.restore();

  // Color variation spots
  ctx.save();
  ctx.globalCompositeOperation = 'soft-light';
  for (let i = 0; i < 30; i++) {
    const angle = Math.random() * Math.PI * 2;
    const dist = pupilRadius + Math.random() * (irisRadius - pupilRadius) * 0.8;
    const spotR = 5 + Math.random() * 15;
    const grad = ctx.createRadialGradient(
      cx + Math.cos(angle) * dist, cy + Math.sin(angle) * dist, 0,
      cx + Math.cos(angle) * dist, cy + Math.sin(angle) * dist, spotR
    );
    const hue = Math.random() * 360;
    grad.addColorStop(0, `hsla(${hue}, 40%, 50%, 0.3)`);
    grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, size, size);
  }
  ctx.restore();

  // Limbal ring (dark outer edge)
  ctx.save();
  ctx.globalCompositeOperation = 'multiply';
  const limbalGrad = ctx.createRadialGradient(cx, cy, irisRadius * 0.82, cx, cy, irisRadius);
  limbalGrad.addColorStop(0, 'rgba(0,0,0,0)');
  limbalGrad.addColorStop(0.7, 'rgba(20,15,10,0.5)');
  limbalGrad.addColorStop(1, 'rgba(10,8,5,0.9)');
  ctx.beginPath();
  ctx.arc(cx, cy, irisRadius, 0, Math.PI * 2);
  ctx.fillStyle = limbalGrad;
  ctx.fill();
  ctx.restore();

  // Pupil hole (black center)
  ctx.save();
  ctx.globalCompositeOperation = 'source-over';
  const pupilGrad = ctx.createRadialGradient(cx, cy, pupilRadius * 0.85, cx, cy, pupilRadius);
  pupilGrad.addColorStop(0, 'rgb(0,0,0)');
  pupilGrad.addColorStop(1, 'rgba(0,0,0,0.95)');
  ctx.beginPath();
  ctx.arc(cx, cy, pupilRadius, 0, Math.PI * 2);
  ctx.fillStyle = pupilGrad;
  ctx.fill();
  ctx.restore();

  irisCanvas = canvas;
  const tex = new THREE.CanvasTexture(canvas);
  tex.needsUpdate = true;
  irisTexture = tex;
  currentIrisColor = colorString;
  return tex;
}

function createEnvMap(renderer, scene) {
  const size = 256;
  const canvas = document.createElement('canvas');
  canvas.width = size * 4;
  canvas.height = size * 2;
  const ctx = canvas.getContext('2d');

  // Dark gradient background
  const bg = ctx.createLinearGradient(0, 0, 0, canvas.height);
  bg.addColorStop(0, '#222');
  bg.addColorStop(0.5, '#111');
  bg.addColorStop(1, '#0a0a0a');
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Bright key-light spot (upper right area)
  const spotGrad = ctx.createRadialGradient(canvas.width * 0.65, canvas.height * 0.25, 0, canvas.width * 0.65, canvas.height * 0.25, canvas.width * 0.15);
  spotGrad.addColorStop(0, 'rgba(255,250,240,1)');
  spotGrad.addColorStop(0.3, 'rgba(255,245,230,0.6)');
  spotGrad.addColorStop(1, 'rgba(255,240,220,0)');
  ctx.fillStyle = spotGrad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Secondary fill spot (left)
  const fillGrad = ctx.createRadialGradient(canvas.width * 0.2, canvas.height * 0.4, 0, canvas.width * 0.2, canvas.height * 0.4, canvas.width * 0.12);
  fillGrad.addColorStop(0, 'rgba(200,210,230,0.4)');
  fillGrad.addColorStop(1, 'rgba(200,210,230,0)');
  ctx.fillStyle = fillGrad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const envTexture = new THREE.CanvasTexture(canvas);
  envTexture.mapping = THREE.EquirectangularReflectionMapping;

  const pmremGenerator = new THREE.PMREMGenerator(renderer);
  pmremGenerator.compileEquirectangularShader();
  const envMap = pmremGenerator.fromEquirectangular(envTexture).texture;
  pmremGenerator.dispose();
  envTexture.dispose();

  return envMap;
}

function createEyelids() {
  const lidColor = 0x2a1f1a;
  const lidMaterial = new THREE.MeshPhysicalMaterial({
    color: lidColor,
    roughness: 0.8,
    metalness: 0.0,
    side: THREE.DoubleSide
  });

  // Upper eyelid
  const upperPivot = new THREE.Group();
  upperPivot.position.set(0, 0.05, 0);
  const upperGeo = new THREE.SphereGeometry(1.08, 64, 32, 0, Math.PI * 2, 0, Math.PI * 0.48);
  const upperMesh = new THREE.Mesh(upperGeo, lidMaterial);
  upperMesh.rotation.x = -Math.PI * 0.02;
  upperPivot.add(upperMesh);
  eyeballGroup.add(upperPivot);
  eyeballUpperLid = upperPivot;

  // Lower eyelid
  const lowerPivot = new THREE.Group();
  lowerPivot.position.set(0, -0.05, 0);
  const lowerGeo = new THREE.SphereGeometry(1.08, 64, 32, 0, Math.PI * 2, Math.PI * 0.55, Math.PI * 0.45);
  const lowerMesh = new THREE.Mesh(lowerGeo, lidMaterial);
  lowerMesh.rotation.x = Math.PI * 0.02;
  lowerPivot.add(lowerMesh);
  eyeballGroup.add(lowerPivot);
  eyeballLowerLid = lowerPivot;

  // Position lids open by default
  eyeballUpperLid.rotation.x = -0.55;
  eyeballLowerLid.rotation.x = 0.35;
}

function addVeinBranch(parent, startPoint, direction, radius, length, depth, maxDepth) {
  if (depth > maxDepth) return;

  const points = [startPoint.clone()];
  const segments = 4 + Math.floor(Math.random() * 3);
  let current = startPoint.clone();
  const dir = direction.clone().normalize();

  for (let i = 0; i < segments; i++) {
    const step = length / segments;
    const wobble = new THREE.Vector3(
      (Math.random() - 0.5) * 0.08,
      (Math.random() - 0.5) * 0.08,
      (Math.random() - 0.5) * 0.03
    );
    current = current.clone().add(dir.clone().multiplyScalar(step)).add(wobble);
    // Project onto sphere surface
    const dist = current.length();
    if (dist > 0.01) current.multiplyScalar(1.0 / dist);
    points.push(current.clone());
  }

  const curve = new THREE.CatmullRomCurve3(points);
  const tubeGeo = new THREE.TubeGeometry(curve, 8, radius, 5, false);
  const veinMat = new THREE.MeshPhysicalMaterial({
    color: 0xaa3333,
    roughness: 0.7,
    metalness: 0.0,
    transparent: true,
    opacity: 0.35 - depth * 0.08,
  });
  const veinMesh = new THREE.Mesh(tubeGeo, veinMat);
  parent.add(veinMesh);

  // Sub-branches
  if (depth < maxDepth) {
    const numBranches = 1 + Math.floor(Math.random() * 2);
    for (let b = 0; b < numBranches; b++) {
      const branchIdx = Math.floor(segments * (0.4 + Math.random() * 0.4));
      const branchPoint = points[Math.min(branchIdx, points.length - 1)];
      const branchDir = dir.clone().applyAxisAngle(
        new THREE.Vector3(0, 0, 1),
        (Math.random() - 0.5) * 1.2
      );
      addVeinBranch(parent, branchPoint, branchDir, radius * 0.6, length * 0.5, depth + 1, maxDepth);
    }
  }
}

function scheduleNextBlink() {
  nextBlinkTime = Date.now() + 2000 + Math.random() * 6000;
}

function initEyeball() {
  if (eyeballScene) return; // Already initialized

  const container = document.getElementById('eyeball-container');

  // Scene
  eyeballScene = new THREE.Scene();
  eyeballScene.background = new THREE.Color(0x0a0a0a);

  // Camera
  eyeballCamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
  eyeballCamera.position.z = 3;

  // Renderer with tone mapping
  eyeballRenderer = new THREE.WebGLRenderer({ antialias: true });
  eyeballRenderer.setSize(window.innerWidth, window.innerHeight);
  eyeballRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  eyeballRenderer.toneMapping = THREE.ACESFilmicToneMapping;
  eyeballRenderer.toneMappingExposure = 1.1;
  container.appendChild(eyeballRenderer.domElement);

  // Environment map for PBR reflections
  const envMap = createEnvMap(eyeballRenderer, eyeballScene);
  eyeballScene.environment = envMap;

  // Eyeball group (for rotation)
  eyeballGroup = new THREE.Group();
  eyeballScene.add(eyeballGroup);

  // Sclera (warm off-white with SSS approximation via sheen)
  const scleraGeometry = new THREE.SphereGeometry(1, 64, 64);
  const scleraMaterial = new THREE.MeshPhysicalMaterial({
    color: 0xf0ebe3,
    roughness: 0.55,
    metalness: 0.0,
    sheen: 0.8,
    sheenRoughness: 0.4,
    sheenColor: new THREE.Color(0xdda0a0),
    clearcoat: 0.15,
    clearcoatRoughness: 0.4,
  });
  eyeballSclera = new THREE.Mesh(scleraGeometry, scleraMaterial);
  eyeballGroup.add(eyeballSclera);

  // Iris with procedural texture
  const irisGeometry = new THREE.SphereGeometry(0.45, 48, 48);
  const irisMap = generateIrisTexture(currentIrisColor);
  const irisMaterial = new THREE.MeshPhysicalMaterial({
    map: irisMap,
    roughness: 0.35,
    metalness: 0.0,
    clearcoat: 0.6,
    clearcoatRoughness: 0.15,
  });
  eyeballIris = new THREE.Mesh(irisGeometry, irisMaterial);
  eyeballIris.position.z = 0.88;
  eyeballIris.scale.z = 0.3;
  eyeballGroup.add(eyeballIris);

  // Pupil
  const pupilGeometry = new THREE.SphereGeometry(0.2, 32, 32);
  const pupilMaterial = new THREE.MeshPhysicalMaterial({
    color: 0x050505,
    roughness: 0.3,
    metalness: 0.0,
  });
  eyeballPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
  eyeballPupil.position.z = 0.98;
  eyeballPupil.scale.z = 0.2;
  eyeballGroup.add(eyeballPupil);

  // Cornea (wet glossy layer with transmission)
  const corneaGeometry = new THREE.SphereGeometry(1.02, 64, 64);
  const corneaMaterial = new THREE.MeshPhysicalMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.15,
    roughness: 0.0,
    metalness: 0.0,
    clearcoat: 1.0,
    clearcoatRoughness: 0.02,
    ior: 1.376,
    transmission: 0.95,
    thickness: 0.1,
  });
  eyeballCornea = new THREE.Mesh(corneaGeometry, corneaMaterial);
  eyeballGroup.add(eyeballCornea);

  // Lighting - 4 light setup
  const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
  eyeballScene.add(ambientLight);

  // Key light (warm)
  const keyLight = new THREE.DirectionalLight(0xfff5e6, 1.2);
  keyLight.position.set(2, 2, 5);
  eyeballScene.add(keyLight);

  // Fill light (cool)
  const fillLight = new THREE.DirectionalLight(0xc8d8f0, 0.4);
  fillLight.position.set(-3, -1, 3);
  eyeballScene.add(fillLight);

  // Point light for crisp specular highlight
  const specLight = new THREE.PointLight(0xffffff, 0.8, 10);
  specLight.position.set(1, 1.5, 4);
  eyeballScene.add(specLight);

  // Rim light for depth
  const rimLight = new THREE.DirectionalLight(0x8899aa, 0.5);
  rimLight.position.set(0, 0, -3);
  eyeballScene.add(rimLight);

  // Add 3D veins
  addVeins();

  // Add eyelids
  createEyelids();

  // Init blink and dilation timing
  scheduleNextBlink();
  nextDilationChangeTime = Date.now() + 3000 + Math.random() * 5000;

  // Handle resize
  window.addEventListener('resize', onEyeballResize);

  // Start animation loop
  animateEyeball();
}

function addVeins() {
  const numVeins = 7;
  for (let i = 0; i < numVeins; i++) {
    const angle = (i / numVeins) * Math.PI * 2 + (Math.random() - 0.5) * 0.3;
    const startRadius = 0.65 + Math.random() * 0.1;

    const x = Math.cos(angle) * startRadius;
    const y = Math.sin(angle) * startRadius;
    const z = Math.sqrt(Math.max(0, 1 - x * x - y * y)) * 0.97;
    const startPoint = new THREE.Vector3(x, y, z);

    // Direction: outward along sclera surface, away from iris
    const direction = new THREE.Vector3(Math.cos(angle), Math.sin(angle), -0.2).normalize();

    addVeinBranch(eyeballGroup, startPoint, direction, 0.006 + Math.random() * 0.004, 0.35, 0, 2);
  }
}

function onEyeballResize() {
  if (!eyeballCamera || !eyeballRenderer) return;
  eyeballCamera.aspect = window.innerWidth / window.innerHeight;
  eyeballCamera.updateProjectionMatrix();
  eyeballRenderer.setSize(window.innerWidth, window.innerHeight);
}

function animateEyeball() {
  if (!eyeballActive) {
    requestAnimationFrame(animateEyeball);
    return;
  }

  requestAnimationFrame(animateEyeball);

  const now = Date.now();
  const time = now * 0.001;

  // Smooth interpolation toward target gaze
  const smoothing = 0.08;
  currentGaze.x += (targetGaze.x - currentGaze.x) * smoothing;
  currentGaze.y += (targetGaze.y - currentGaze.y) * smoothing;

  // Add subtle organic movement
  const microX = Math.sin(time * 1.5) * 0.01;
  const microY = Math.cos(time * 1.3) * 0.01;

  // Apply rotation to eyeball group
  // Limit rotation to realistic eye movement range (~30 degrees)
  const maxRotation = 0.5; // radians
  eyeballGroup.rotation.y = Math.max(-maxRotation, Math.min(maxRotation, currentGaze.x + microX));
  eyeballGroup.rotation.x = Math.max(-maxRotation, Math.min(maxRotation, -(currentGaze.y + microY)));

  // --- Pupil dilation ---
  if (now > nextDilationChangeTime) {
    pupilDilationTarget = 0.7 + Math.random() * 0.6; // range 0.7 to 1.3
    nextDilationChangeTime = now + 3000 + Math.random() * 5000;
  }
  pupilDilationCurrent += (pupilDilationTarget - pupilDilationCurrent) * 0.02;
  if (eyeballPupil) {
    eyeballPupil.scale.x = 0.2 * pupilDilationCurrent;
    eyeballPupil.scale.y = 0.2 * pupilDilationCurrent;
    // Keep z scale thin
    eyeballPupil.scale.z = 0.2;
  }
  if (eyeballIris) {
    // Iris subtly scales inversely — larger pupil = slightly smaller visible iris
    const irisScale = 1.0 + (1.0 - pupilDilationCurrent) * 0.08;
    eyeballIris.scale.x = irisScale;
    eyeballIris.scale.y = irisScale;
    // Keep z scale flat
    eyeballIris.scale.z = 0.3;
  }

  // --- Blinking ---
  if (blinkState === 'open' && now > nextBlinkTime) {
    blinkState = 'closing';
    blinkProgress = 0;
  }

  if (blinkState === 'closing') {
    blinkProgress += 0.016 * blinkSpeed;
    if (blinkProgress >= 1) {
      blinkProgress = 1;
      blinkState = 'closed';
      // Brief pause while closed
      setTimeout(() => { if (blinkState === 'closed') blinkState = 'opening'; }, 50 + Math.random() * 60);
    }
  }

  if (blinkState === 'opening') {
    blinkProgress -= 0.016 * blinkSpeed * 0.7; // open slightly slower
    if (blinkProgress <= 0) {
      blinkProgress = 0;
      blinkState = 'open';
      scheduleNextBlink();
    }
  }

  if (eyeballUpperLid && eyeballLowerLid) {
    const eased = easeInOutCubic(blinkProgress);
    // Upper lid: rotates from -0.55 (open) toward ~0.15 (closed)
    eyeballUpperLid.rotation.x = -0.55 + eased * 0.70;
    // Lower lid: subtle upward movement during blink
    eyeballLowerLid.rotation.x = 0.35 - eased * 0.15;
  }

  eyeballRenderer.render(eyeballScene, eyeballCamera);
}

function showEyeball(msg) {
  hideIdle();
  clearContent('instant');

  // Set iris color before init so texture generates with correct color
  if (msg.irisColor) {
    currentIrisColor = msg.irisColor;
  }

  initEyeball();

  const container = document.getElementById('eyeball-container');
  container.classList.add('active');
  eyeballActive = true;

  // Apply custom iris color if specified (regenerate texture if already initialized)
  if (msg.irisColor && eyeballIris) {
    const newTex = generateIrisTexture(msg.irisColor);
    eyeballIris.material.map = newTex;
    eyeballIris.material.needsUpdate = true;
  }

  // Apply background color
  if (msg.bgColor && eyeballScene) {
    eyeballScene.background = new THREE.Color(msg.bgColor);
  }
}

function hideEyeball() {
  const container = document.getElementById('eyeball-container');
  container.classList.remove('active');
  eyeballActive = false;
  showIdle();
}

function updateEyeballGaze(msg) {
  if (!eyeballActive) return;

  // msg contains face position in world/room coordinates
  const facePos = { x: msg.x || 0, y: msg.y || 0, z: msg.z || 5 };

  // Calculate gaze direction from this display's position to face
  const dx = facePos.x - displayConfig.position.x;
  const dy = facePos.y - displayConfig.position.y;
  const dz = facePos.z - displayConfig.position.z;

  // Apply display rotation
  const rotRad = displayConfig.rotation * Math.PI / 180;
  const rotatedX = dx * Math.cos(rotRad) - dz * Math.sin(rotRad);
  const rotatedZ = dx * Math.sin(rotRad) + dz * Math.cos(rotRad);

  // Convert to normalized gaze (-1 to 1)
  const distance = Math.sqrt(rotatedX * rotatedX + rotatedZ * rotatedZ);
  if (distance > 0.1) {
    targetGaze.x = Math.max(-1, Math.min(1, rotatedX / distance));
    targetGaze.y = Math.max(-1, Math.min(1, dy / Math.max(1, distance)));
  }
}

function configureDisplay(msg) {
  if (msg.position) {
    displayConfig.position = msg.position;
  }
  if (typeof msg.rotation === 'number') {
    displayConfig.rotation = msg.rotation;
  }
  console.log('Display configured:', displayConfig);
}

// --- Start ---
connect();

// Prevent sleep / screensaver with occasional activity
setInterval(() => {
  if (ws && ws.readyState === 1) {
    ws.send(JSON.stringify({ type: 'heartbeat' }));
  }
}, 30000);
</script>
</body>
</html>
